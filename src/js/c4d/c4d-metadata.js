// Copyright 2017 Google Inc.
//
//   Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
// limitations under the License.


/**
 * C4DMetadata
 *
 * Class for parsing and handling metadata stored in GLTF models exported
 * from Cinema 4D. The metadata for a given object is stored in the object's
 * name, and is generated by the COLLADA Export Plus plugin within Cinema4D.
 *
 * The plugin allows an artist to attach shaders properties, xrefs, and custom
 * data to an object within Cinema4D. These properties are parsed and applied by 
 * this class.
 */

import { C4DExportLoader } from './c4d-export-loader';
import { C4DLinkObject } from './c4d-link-object';
import { C4DUtils } from './c4d-utils';

const ColorShader = require( '../shaders/color-shader' );
const ColorAlphaShader = require( '../shaders/color-alpha-shader' );
const LambertShader = require( '../shaders/rover-lambert-shader' );
const UnlitMapShader = require( '../shaders/unlit-map-shader' );
const FXLineShader = require( '../shaders/flashline-shader' );

export const METADATA_TAG = 'METADATA';
export const DATUM_SEPARATOR = '___';
export const PARAM_SEPARATOR = '_';

export const DATUM_TEXTURE = 'TEX';
export const DATUM_SHADER = 'SHADER';
export const DATUM_COLOR = 'MATCOLOR';
export const DATUM_XREF = 'XREF';
export const DATUM_TYPE = 'TYPE';
export const DATUM_HITBOX = 'HITBOX';
export const DATUM_OPACITY = 'OPACITY';
export const DATUM_UNIFORM = 'UNIFORM';
export const DATUM_TRANSFORM = 'TRANSFORM';
export const DATUM_LINKOBJ = 'LINKOBJ';
export const DATUM_TARGET = 'TARGET';
export const DATUM_HIGHLIGHT = 'HIGHLIGHT';
export const DATUM_HIGHLIGHTMAP = 'HIGHLIGHTMAP';
export const DATUM_SIZE = 'SIZE';
export const DATUM_XSMALL = 'XSM';
export const DATUM_SMALL = 'SM';
export const DATUM_MEDIUM = 'MD';
export const DATUM_LARGE = 'LG';
export const DATUM_ID = 'ID';

const SHADER_NAME_BASIC = 'BASIC';
const SHADER_NAME_LAMBERT = 'LAMBERT';
const SHADER_NAME_FX_LINES = 'FXLINES';
const SHADER_NAME_UNLIT_MAP = 'UNLITMAP';

export class C4DMetadata {

	constructor( xrefPath, texPath ) {
		this.xrefPath = xrefPath || '';
		this.texPath = texPath || '';
	}

	/**
	 * Parses and applies any metadata found in a given object.
	 * Returns a promise which resolves when the parsing is complete.
	 */
	parse( obj ) {
		return new Promise( ( resolve, reject ) => {
			if ( !obj.name.includes( METADATA_TAG ) ) { resolve( null ); return; }

			this.obj = obj;
			this.mesh = C4DUtils.getChildWithType( this.obj, 'Mesh' );
			this.material = null;

			this.obj.metadata = GetMetadataFromName( this.obj.name );
			this.obj.metadata.object = this.obj;
			this.obj.metadata.mesh = this.mesh;

			const promises = [];
			
			promises.push( this.handleTextureDatum() );
			promises.push( this.handleHighlightMapDatum() );
			promises.push( this.handleXRefDatum() );

			Promise.all( promises ).then( results => {
				this.applyMaterial();
				this.getLinkObject();

				resolve( this.obj.metadata );
			});
		});
	}

	/**
	 * Loads any relevant textures specified in the metadata.
	 * Returns a promise which resolves when the texture is loaded.
	 */
	handleTextureDatum() {
		return new Promise( ( resolve, reject ) => {
			if ( !this.obj.metadata.texture ) { resolve(); return; }
			
			const src = this.texPath + this.obj.metadata.texture;
			const texLoader = new THREE.TextureLoader();

			this.obj.metadata.texture = texLoader.load( src, texture => {
				resolve();
			}, progress => {}, error => {
				reject( error );
			});
		});
	}

	/**
	 * Loads any relevant highlight map images specified in the metadata.
	 * Returns a promise which resolves when the image is loaded.
	 */
	handleHighlightMapDatum() {
		return new Promise( ( resolve, reject ) => {
			if ( !this.obj.metadata.highlightMap ) { resolve(); return; }

			const src = this.texPath + this.obj.metadata.highlightMap;
			const texLoader = new THREE.TextureLoader();

			this.obj.metadata.highlightMap = texLoader.load( src, texture => {
				resolve();
			}, progress => {}, error => {
				reject( error );
			});
		});
	}

	/**
	 * Loads any external xref'd models specified in the metadata.
	 * Returns a promise which resolves when the model is loaded.
	 */
	handleXRefDatum() {
		return new Promise( ( resolve, reject ) => {
			if ( !this.obj.metadata.xref ) { resolve(); return; }

			const src = this.xrefPath + this.obj.metadata.xref + '.glb'
			const xrefLoader = new C4DExportLoader();

			xrefLoader.load( src, this.xrefPath, this.texPath ).then( response => {
				response.scene.scale.copy( new THREE.Vector3( 100, 100, 100 ) );
				this.obj.add( response.scene );
				resolve();
			});
		});
	}

	/**
	 * Creates any C4DLinkObjects specified in the metadata.
	 * A C4DLinkObject binds an object's animated position parameter
	 * to a shader parameter of a target object. This allows an artist
	 * to animate THREEJS shader parameters within Cinema4D.
	 */
	getLinkObject() {
		if ( !this.obj ) return;
		if ( !this.obj.metadata ) return;
		if ( !this.obj.metadata.shaderLinkTarget ) return;
		if ( !this.obj.metadata.shaderLinkUniform && !this.obj.metadata.transformLink ) return;

		this.obj.metadata.linkObject = new C4DLinkObject( this.obj );
	}

	/**
	 * Creates and applies a new material based on any relevant parameters 
	 * specified in the metadata.
	 */
	applyMaterial() {
		if ( !this.obj ) return;
		if ( !this.mesh ) return;
		if ( this.obj.metadata.type === 'TILE' ) return;
		
		var shader = null;

		// Get the correct shader for the given object's shader name
		switch ( this.obj.metadata.shaderName ) {
			case SHADER_NAME_BASIC: 	shader = this.obj.metadata.transparent ? ColorAlphaShader : ColorShader; break;
			case SHADER_NAME_LAMBERT: 	shader = LambertShader; break;
			case SHADER_NAME_UNLIT_MAP: shader = UnlitMapShader; break;
			case SHADER_NAME_FX_LINES: 	shader = FXLineShader; break;
		}

		// Create uniforms object from the correct shader
		const uniforms = THREE.UniformsUtils.clone( shader.uniforms );

		// Set map uniform if a texture exists
		if ( this.obj.metadata.texture && uniforms.hasOwnProperty( 'map' ) ) {
			uniforms.map.value = this.obj.metadata.texture;
		}

		// Set highlight map uniform if it exists
		if ( this.obj.metadata.highlightMap && uniforms.hasOwnProperty( 'highlightMap' ) ) {
			uniforms.highlightMap.value = this.obj.metadata.highlightMap;
		}

		// Set opacity uniform if it exists
		if ( this.obj.metadata.transparent && uniforms.hasOwnProperty( 'opacity' ) ) {
			uniforms.opacity.value = this.obj.metadata.opacity;
		}

		// Set color uniform if it exists
		if ( this.obj.metadata.color && uniforms.hasOwnProperty( 'color' ) ) {
			uniforms.color.value = this.obj.metadata.color;
		}

		// Create and apply a new ShaderMaterial
		this.mesh.material = new THREE.ShaderMaterial({
			uniforms: uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			transparent: this.obj.metadata.transparent,
			side: THREE.DoubleSide
		});

		this.obj.metadata.material = this.mesh.material;
	}
}

/**
 * Static function for parsing the metadata stored in an object's name string.
 * Returns an object with the parsed metadata.
 */
export let GetMetadataFromName = function( name ) {

	// Set defaults
	const result = {
		type: null,
		color: new THREE.Color( 0xFFFFFF ),
		opacity: 1,
		shaderName: SHADER_NAME_BASIC,
		shaderLinkTarget: null,
		shaderLinkUniform: null,
		transformLink: null,
		transparent: false,
		highlightMap: null,
		highlight: null,
		texture: null,
		hitbox: null,
		target: null,
		xref: null,
		size: 64,
		id: null,
		xsmallPrefix: '_xsm',
		smallPrefix: '_sm',
		hasMediumSize: false,
		hasLargeSize: false,
		material: null,
		object: null,
		mesh: null
	};
		
	name.split( METADATA_TAG ).pop().split( DATUM_SEPARATOR ).forEach( d => {
		if ( !d.length ) return;

		const i = d.indexOf( PARAM_SEPARATOR );
		const datumType = d.slice( 0, i === -1 ? undefined : i );
		const datumParam = d.slice( i + 1 );

		switch ( datumType ) {

			case DATUM_TEXTURE:
				result.texture = datumParam;
				break;

			case DATUM_COLOR:
				result.color = new THREE.Color( '#' + datumParam );
				break;

			case DATUM_OPACITY:
				result.opacity = parseFloat( datumParam ) * 100;
				result.transparent = true;
				break;

			case DATUM_SHADER:
				result.shaderName = datumParam;
				break;

			case DATUM_TYPE:
				result.type = datumParam;
				break;

			case DATUM_XREF:
				result.xref = datumParam;
				break;

			case DATUM_HITBOX:
				result.hitbox = datumParam;
				break;

			case DATUM_TARGET:
				result.target = datumParam;
				break;

			case DATUM_LINKOBJ:
				result.shaderLinkTarget = datumParam;
				break;

			case DATUM_UNIFORM:
				result.shaderLinkUniform = datumParam;
				break;

			case DATUM_TRANSFORM:
				result.transformLink = datumParam;
				break;

			case DATUM_HIGHLIGHT:
				result.highlight = datumParam;
				break;

			case DATUM_HIGHLIGHTMAP:
				result.highlightMap = datumParam;
				break;

			case DATUM_SIZE:
				result.size = parseFloat( datumParam );
				break;

			case DATUM_XSMALL:
				result.xsmallPrefix = '_' + datumParam;
				break;

			case DATUM_SMALL:
				result.smallPrefix = '_' + datumParam;
				break;

			case DATUM_MEDIUM: 
				result.hasMediumSize = datumParam === '1';
				break;

			case DATUM_LARGE:
				result.hasLargeSize = datumParam === '1';
				break;

			case DATUM_ID:
				result.id = datumParam;
				break;
		}
	});

	return result;
}